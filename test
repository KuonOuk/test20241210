import boto3
import logging
import csv
from botocore.exceptions import ClientError

# AWS Glue クライアントの初期化
glue = boto3.client('glue')


def get_all_glue_jobs():
    """
    全てのAWS Glueジョブを取得
    """
    try:
        jobs = []

        # 初回のジョブリスト取得
        response = glue.get_jobs()
        jobs.extend(response['Jobs'])

        # ページネーションの処理
        while 'NextToken' in response:
            response = glue.get_jobs(NextToken=response['NextToken'])
            jobs.extend(response['Jobs'])

        return jobs

    except ClientError as err:
        logging.error("ジョブを取得できませんでした。原因: %s: %s", err.response["Error"]["Code"], err.response["Error"]["Message"])
    except Exception as err:
        logging.error("ジョブの取得処理中にエラーが発生しました: %s", err)
    return []


def get_all_job_runs(job_name):
    """
    指定されたAWS Glueジョブの全履歴を取得
    """
    try:
        job_runs = []

        # 初回のジョブ履歴取得
        response = glue.get_job_runs(JobName=job_name)
        job_runs.extend([run for run in response['JobRuns'] if 'StartedOn' in run and 'CompletedOn' in run])

        # ページネーションの処理
        while 'NextToken' in response:
            response = glue.get_job_runs(JobName=job_name, NextToken=response['NextToken'])
            job_runs.extend([run for run in response['JobRuns'] if 'StartedOn' in run and 'CompletedOn' in run])

        return job_runs

    except ClientError as err:
        logging.error("ジョブ履歴を取得できませんでした。原因: %s: %s", err.response["Error"]["Code"], err.response["Error"]["Message"])
    except Exception as err:
        logging.error("ジョブ履歴の取得処理中にエラーが発生しました: %s", err)
    return []


def calculate_max_concurrent_jobs(job_runs):
    """
    同時実行ジョブ数の最大値を計算
    """
    job_runs.sort(key=lambda job: job['StartedOn'])

    max_concurrent_jobs = 0
    current_jobs = 0
    events = []

    for run in job_runs:
        events.append((run['StartedOn'], 1))  # 開始イベント
        events.append((run['CompletedOn'], -1))  # 終了イベント

    events.sort(key=lambda job: job[0])

    for event in events:
        current_jobs += event[1]
        max_concurrent_jobs = max(max_concurrent_jobs, current_jobs)

    return max_concurrent_jobs


def get_job_concurrent_counts(jobs):
    """
    各ジョブの同時実行ジョブの最大数を取得
    """
    job_concurrent_counts = []

    for job in jobs:
        job_name = job['Name']
        job_runs = get_all_job_runs(job_name)
        if not job_runs:
            max_concurrent_jobs = 0
        else:
            max_concurrent_jobs = calculate_max_concurrent_jobs(job_runs)

        job_concurrent_counts.append({'JobName': job_name, 'MaxConcurrentJobs': max_concurrent_jobs})

    return job_concurrent_counts


def save_jobs_and_concurrent_counts_to_csv(jobs, job_concurrent_counts, file_name="glue_jobs.csv"):
    """
    ジョブ名と同時実行ジョブの最大数をCSVファイルに保存
    """
    try:
        with open(file_name, mode='w', newline='', encoding='utf-8') as file:
            writer = csv.writer(file)
            writer.writerow(["ジョブ名", "ジョブの同時実行ジョブの最大数"])  # ヘッダー

            for job in job_concurrent_counts:
                writer.writerow([job['JobName'], job['MaxConcurrentJobs']])

        print(f"ジョブ名と同時実行ジョブの最大数が {file_name} に保存されました。")

    except Exception as err:
        logging.error("CSVファイルの保存中にエラーが発生しました: %s", err)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)

    # 全てのジョブを取得
    all_jobs = get_all_glue_jobs()
    job_count = len(all_jobs)
    print(f"アカウント内のジョブの最大数: {job_count}")

    # 各ジョブの同時実行ジョブの最大数を取得
    job_concurrent_counts = get_job_concurrent_counts(all_jobs)

    # CSVに保存
    save_jobs_and_concurrent_counts_to_csv(all_jobs, job_concurrent_counts)
